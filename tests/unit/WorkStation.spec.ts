import {WorkStation} from '@/classes/WorkStation';
import {UnfairDice} from '../toolbox/UnfairDice';
import {UnfairRngFactory} from '../toolbox/UnfairRngFactory';


describe('WorkStation', () => {
    let workStation: WorkStation;

    beforeEach(() => {
        workStation = new WorkStation(new UnfairRngFactory());
        workStation.setWaitMultiplier(0);
    });

    it('defaults to being created with one worker on it', () => {
        expect(workStation.numberOfWorkers).toBe(1);
    });

    it('calculates total effort generated by adding the effort of each worker', async () => {
        UnfairDice.guaranteedRollValue = 2; // Any value
        workStation.setNumberOfWorkers(5);  // Any value

        const expectation = UnfairDice.guaranteedRollValue * workStation.numberOfWorkers;
        expect(await workStation.recalculateEffort()).toEqual(expectation);
    });

    it('decreases the input by the amount of effort generated in the work cycle', async () => {
        workStation.setInput(100);
        workStation.setNumberOfWorkers(1);
        UnfairDice.guaranteedRollValue = 5;

        await workStation.work();
        expect(workStation.input).toEqual(100 - 5);
    });

    it('requires both effort and input to produce each unit of output', async () => {
        workStation.setInput(5); // Very low amount of input
        workStation.setNumberOfWorkers(10); // Very strong effort generation
        UnfairDice.guaranteedRollValue = 10;

        // It's expected that the output generated with be very low, due to the shortage of input
        await workStation.work();
        expect(workStation.input).toEqual(0); // All input was processed
        expect(workStation.effortRemaining).toEqual(95); // Lots of wasted effort
        expect(workStation.output).toEqual(5); // All 5 units of input got converted into output
    });
});
